GibberLink

GibberLink is a Python-based project that simulates secure communication between two clients (Client1 and Client2) using Frequency Shift Keying (FSK) modulation to encode messages as audio waveforms. Messages are encrypted with a symmetric key (Fernet) exchanged via RSA key pairs generated by OpenSSL, ensuring secure data transmission. The system generates WAV files containing encoded messages and logs all events for transparency. A separate decoder script extracts and decrypts messages from these WAV files using RSA private keys.
Note: Audio playback is disabled by default due to potential issues on some systems, particularly virtual machines with shared sound cards. The project focuses on generating and decoding WAV files, which can be played externally to hear modem-like tones.
Features
Secure Communication: Uses OpenSSL-generated RSA key pairs for public key exchange and Fernet for symmetric encryption of messages.

FSK Modulation: Encodes messages as audio using FSK (1000 Hz for bit 0, 2000 Hz for bit 1) with smooth chirps and amplitude envelopes for a modem-like sound.
WAV File Output: Saves encoded messages as WAV files in the audio/ directory for offline analysis or playback.
Key Management: Stores RSA private and public keys in the keys/ directory as PEM files.
Logging: Detailed event logging in gibberlink_log.txt for debugging and transparency.
Decoding: Separate script (GibberLinkDecoder.py) to decode and decrypt messages from WAV files using RSA private keys.
Cross-Platform: Designed to run on Linux (e.g., Ubuntu), with considerations for virtual machine environments.

Prerequisites
Python 3.8+

Dependencies:
Python packages: numpy, cryptography
System package: openssl
Optional (for audio playback): pyaudio, libportaudio2, portaudio19-dev
Operating System: Tested on Ubuntu; may require adjustments for other systems.

Optional Tools:
VLC or Audacity for playing/inspecting WAV files.

Virtual environment for dependency management.

Installation
Clone or Download the Project:
```
git clone https://github.com/404-Panda/GibberLink-Encrypted.git
cd GibberLink
```
Set Up a Virtual Environment:
```
python3 -m venv venv
source venv/bin/activate
```
Install Python Dependencies:

```
pip install numpy cryptography
```
Install OpenSSL:

```
sudo apt update
sudo apt install openssl
```
Optional: Install Audio Playback Dependencies:
If enabling audio playback (set PLAY_AUDIO = True in GibberLinkGenerate.py):

```
pip install pyaudio
sudo apt install libportaudio2 portaudio19-dev
```
Optional: Install VLC or Audacity:
For playing or inspecting WAV files:

```
sudo apt install vlc audacity
```
File Structure

GibberLink/
├── GibberLinkGenerate.py     # Generates encrypted FSK audio messages
├── GibberLinkDecoder.py      # Decodes and decrypts messages from WAV files
├── audio/                    # Directory for generated WAV files
├── keys/                     # Directory for RSA key files
├── gibberlink_log.txt        # Log file for communication events
├── venv/                     # Virtual environment (optional)
└── README.md                 # Project documentation

Usage
Generating Messages
Run the Generator Script:
```
python3 GibberLinkGenerate.py
```
Creates audio/ and keys/ directories if they don’t exist.
Generates RSA key pairs for Client1 and Client2 (e.g., keys/Client1_private.pem).
Performs a handshake to exchange public keys.
Client1 generates a symmetric key, encrypts it with Client2’s public key, and sends it.
Both clients exchange encrypted messages simulating an AI-to-AI conversation (e.g., hotel booking).
Saves WAV files in audio/ (e.g., Client1_handshake_*.wav, Client1_message_0_*.wav).

Logs events in gibberlink_log.txt.

Example Output:

Starting secure Gibberlink communication...
Client1 started at 2025-06-08 03:00:00.123456
Client1 generated private key: keys/Client1_private.pem
Client1 generated public key: keys/Client1_public.pem
Client1 sending handshake with public key (saved in keys/Client1_public.pem):
Saved audio file: audio/Client1_handshake_1749346800.wav
...
Client1 established secure connection with symmetric key
Client1 encoding encrypted message: {'sender': 'AI_1', 'receiver': 'AI_2', 'text': 'Hello, AI_2! Ready to book a hotel?'}
Saved audio file: audio/Client1_message_0_1749346802.wav
...
Chat session ended at 2025-06-08 03:00:08.123456

Inspect WAV Files:
Play WAV files to hear modem-like tones:

```
vlc audio/*.wav
```
Or inspect with Audacity:

```
audacity audio/Client1_message_0_*.wav
```
Decoding Messages
Decode a Single WAV File:
For handshake (unencrypted):

```
python3 GibberLinkDecoder.py audio/Client1_handshake_1749346800.wav
```
Output:
```
Decoded message from audio/Client1_handshake_1749346800.wav:
{
  "sender": "Client1",
  "receiver": "other",
  "type": "handshake",
  "public_key": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhki...\n-----END PUBLIC KEY-----\n"
}
```
For key exchange (requires private key):

```
python3 GibberLinkDecoder.py audio/Client1_key_exchange_1749346801.wav keys/Client2_private.pem
```
Output:
Extracted symmetric key from audio/Client1_key_exchange_1749346801.wav
For encrypted message (requires symmetric key, currently manual):

```
python3 GibberLinkDecoder.py audio/Client1_message_0_1749346802.wav
```
Note: Message decoding requires the symmetric key; see Limitations for automation needs.

Batch Decode:
```
for file in audio/*.wav; do
    if [[ $file == *_handshake_* ]]; then
        python3 GibberLinkDecoder.py "$file"
    elif [[ $file == *_key_exchange_* ]]; then
        python3 GibberLinkDecoder.py "$file" keys/Client2_private.pem
    else
        python3 GibberLinkDecoder.py "$file"  # Manual symmetric key needed
    fi
done
```
Limitations
Audio Playback: Disabled by default (PLAY_AUDIO = False) due to potential issues on some systems, especially virtual machines with shared sound cards (e.g., Ensoniq AudioPCI on Ubuntu VMs). 
ALSA/PipeWire conflicts may cause crashes or silent playback. Use VLC or Audacity to play WAV files externally.
Symmetric Key Handling: The decoder requires manual handling of the symmetric key for message decryption. Automation for chaining key exchange and message decoding is planned.
RSA Key Size: Uses 2048-bit RSA keys; for production, consider stronger keys or additional security measures.
FSK Robustness: The FSK modulation (1000 Hz, 2000 Hz) is reliable for WAV files but may be sensitive to noise if used with real audio transmission (not implemented).
Virtual Machine Issues: Tested in Ubuntu VMs; audio playback may require VM audio driver adjustments (e.g., PulseAudio or PipeWire).

Troubleshooting
Script Crashes:
Check gibberlink_log.txt for errors.
Ensure openssl is installed: openssl version.
Verify dependencies: pip list | grep 'numpy\|cryptography'.

Decoding Fails:
Confirm key files exist: ls keys/.
Inspect WAV files with Audacity for integrity.
Ensure correct private key is used for key exchange decoding.

No Audio Output:
Play WAV files with VLC: vlc audio/*.wav.
Check VM audio settings (e.g., VirtualBox Audio Controller set to PulseAudio).

Run diagnostics:
pactl info
pactl list sinks short
systemctl --user status pipewire pipewire-pulse

Tones Sound Harsh:
The FSK tones use chirps and envelopes for a modem-like sound. Adjust encode_fsk parameters (e.g., chirp range ±50 Hz) for different effects.

Future Enhancements
Automate symmetric key handling in GibberLinkDecoder.py to decode messages seamlessly after key exchange.
Implement real audio transmission using microphones for live communication.
Enhance FSK tones with additional modulation techniques (e.g., phase modulation).
Add support for stronger cryptographic algorithms or key sizes.
Integrate dynamic message generation using an AI API (e.g., xAI’s API).

License
This project is licensed under the MIT License. See LICENSE file for details (not included in this repository yet).
Acknowledgments
Built with Python, NumPy, Cryptography, and OpenSSL.

Inspired by retro modem communication and secure messaging protocols.
